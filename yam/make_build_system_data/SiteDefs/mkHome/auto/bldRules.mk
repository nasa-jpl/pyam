########################################################################
#
#  !!!!!! DO NOT EDIT THIS FILE !!!!!!
#
#  This file is created by pyam.
#
########################################################################
#
# Define some useful rules for Makefile.yam
#

#======================================================
# dummy rule to invoke 'make all' if just 'make' is typed
help::
	@echo ""
	@echo "   Specify one of the following module build targets:"
	@echo "       mklinks, rmlinks, links, docs, libs, libsso, bins, clean, regtest, supp-map"
	@echo "    or build => links, docs, libs, libsso, bins"
	@echo "    or all => mklinks, build"
	@echo ""
	@echo "    Other available rules are:"
	@echo "       help => generates this message"
	@echo "       alltgt-<RULE> => builds the specified RULE for"
	@echo "                        all available targets"
	@echo "       quiet-alltgt-<RULE> => quiet version of alltgt-<RULE>"
	@echo "       bg-alltgt-<RULE> => background mode version of alltgt-<RULE>"
	@echo "      The ALLTGT variable can be used to restrict the 'alltgt' targets."
	@echo ""


#=======================================================
#              Utility rules
#=======================================================

# rule to print out build variable values
ECHOVARS = MODULE_SUPPORTED_TARGETS MODULE_SUPPORTED_OS MODULE_UNSUPPORTED_TARGETS HH\
		SITE_UNSUPPORTED_TARGETS SITE_SUPPORTED_TARGETS IS_VALID_TARGET \
		SITE_SUPPORTED_OS SITE_UNSUPPORTED_OS OSPOOL ALL_YAM_OS GG \
		BUILDING_SHARED_LIBS CC_COMPILE_FLAGS ALL_YAM_TARGETS
echovars:
	@$(foreach i, $(ECHOVARS), echo "$i=<$($i)>";)

# rule to print out variables specified from the command line
myvars:
	@$(foreach i, $(MYVARS), echo "$i=<$($i)>";)

#======================================================
# rule to generate the supported targets map for a module

supp-map:
	@echo "$(MODULE_NAME):$(VALID_STATUS):$(YAM_SITE):$(HOST):$(YAM_NATIVE):$(YAM_TARGET)"

# generate a graceful error message in case of an unrecognized rule
.DEFAULT:
	@echo "=== The \"$@\" rule is not defined for the \"$(MODULE_NAME)\" module ==="

# turn off some of the implicit rules - (is this working right????)
.SUFFIXES:
SUFFIXES :=

#=======================================================
#              Basic build rules
#=======================================================

#======================================================
# set a flag indicating whether or not this target is supported
# The space after YAM_TARGET below is important. It avoids
# the detection of sparc-sunos5 sparc-sunos5.6
ifneq ($(findstring $(YAM_TARGET) ,$(MODULE_SUPPORTED_TARGETS) ),)
    IS_VALID_TARGET := true
else
    IS_VALID_TARGET :=
endif

# generate a variable for use with in the supp-map rule
# we cannot use IS_VALID_TARGET directly because it is used
# in $(if ... ) rules where a variable is either empty or non-empty.
ifeq ($(IS_VALID_TARGET),true)
  VALID_STATUS := true
else
  VALID_STATUS := false
endif

#====================================================
valid_msg:
	@echo "!!!** The '$(YAM+TARGET)' rule is supported for \"$(MODULE_NAME)\" !!!"

invalid_msg:
ifeq ($(YAM_NATIVE),$(YAM_TARGET))
	@echo "*** The '$(YAM_TARGET)' target is not supported for \"$(MODULE_NAME)\" ***"
else
	@echo "*** The '$(YAM_TARGET)' cross-compilation target is not supported for \"$(MODULE_NAME)\" (from the \"$(YAM_NATIVE)\" native platform) ***"
endif


checkSiteConfig:
ifeq ($(SITECONFIGFILE),)
	@echo ""
	@echo "********* Error: Did not find a site-config file for this build **********"
	@echo "	YAM_SITE=$(YAM_SITE), YAM_NATIVE=$(YAM_NATIVE), YAM_TARGET=$(YAM_TARGET)"
	@echo ""
endif

ifneq ($(wildcard $(LOCAL_DIR)/YamVersion.h),)
export YAM_VERSION = $(shell perl -ne 'print if s@.*DVERSION_RELEASE "(.*)"@\1@' $(LOCAL_DIR)/YamVersion.h)
endif

#======================================================
# For "unix" we build shared libraries if the BUILDING_SHARED_LIBS variable value
# is true, or else static libraries are built. Static libraries are built
# in addition to the shared ones if the BUILD_STARIC_LIBS variable is true.
# The library suffix, LIB_SUFFIX, is set to "a" for static libraries under unix.
#
# For "VxWorks", the static libraries rule is used execpt that the library
# suffix, LIB_SUFFIX, is set to "ro"

# These variable definitions have been moved over from makefile-yam.mk file
# since they are needed early on.

ifeq ($(YAM_OS),unix)
  ifeq ($(BUILDING_SHARED_LIBS),true)
    LIB_SHARED_SUFFIX := so
  else
    BUILD_STATIC_LIBS := true
  endif
endif

# for the VxWorks libraries
ifeq ($(YAM_OS),vx)
  BUILD_STATIC_LIBS := true
  LIB_SUFFIX := ro
endif

ifeq ($(YAM_OS_TMP),windows)
  BUILD_STATIC_LIBS := true
  LIB_SUFFIX := a
  LIB_SHARED_SUFFIX := dll
endif

ifeq ($(YAM_OS),unix)
  LIB_SUFFIX := a
endif

# assume this is a work module unless overridden
IS_WORK_MODULE ?= true

# disable copying of links to physical files for work modules
ifeq ($(IS_WORK_MODULE),true)
  CPLINKS := 0
endif
#======================================================
#build: links depends docs libs libsso bins
build: $(YAM_BUILD_RULES)

all: mklinks build

# ===== STUB RULES ====

# Declare these rules as PHONY targets
# It helps with performance because the make process no longer does
# implicit rule checking for these targets
.PHONY: $(addsuffix -std, mklinks rmlinks $(YAM_LINKMOD_RULES) $(YAM_WORKMOD_RULES) build all) \
        $(addsuffix -module, mklinks rmlinks $(YAM_LINKMOD_RULES) $(YAM_WORKMOD_RULES) $(YAM_ALLRGT_WORKMOD_RULES) $(YAM_ALLTGT_RULES) build all) \
        $(addsuffix -true, mklinks rmlinks $(YAM_LINKMOD_RULES) $(YAM_WORKMOD_RULES) $(YAM_ALLRGT_WORKMOD_RULES) $(YAM_ALLTGT_RULES) build all) \
        $(addsuffix -real, mklinks rmlinks $(YAM_LINKMOD_RULES) $(YAM_WORKMOD_RULES) $(YAM_ALLRGT_WORKMOD_RULES) $(YAM_ALLTGT_RULES) build all) \
        mklinks rmlinks $(YAM_LINKMOD_RULES) $(YAM_WORKMOD_RULES) $(YAM_ALLRGT_WORKMOD_RULES) $(YAM_ALLTGT_RULES) \
        mklinks-real mklinks-regular mklinks-mod mklinks-target rmlinks-real rmlinks-regular rmlinks-mod rmlinks-target checkSiteConfig


# define the "-std" standard rules for Makefile.yam
$(addsuffix -std, mklinks rmlinks $(YAM_LINKMOD_RULES) $(YAM_WORKMOD_RULES) $(YAM_ALLTGT_WORKMOD_RULES) $(YAM_ALLTGT_RULES) build all):

# define the "-module" rules that users can use to extend the standard rules
# these rules are made :: instead of : to support generic "model" module
#   Mekfile.yams which need to define standard rules for these modules,
#   while still allowing users to extend them for instances such as
#   wrapper model modules
$(addsuffix -module, mklinks rmlinks $(YAM_LINKMOD_RULES) $(YAM_WORKMOD_RULES) $(YAM_ALLTGT_WORKMOD_RULES) $(YAM_ALLTGT_RULES) build all)::

# define the "-true" rules that are around for backwords compatibility
# this rule should be DELETED when all the -true variants of rules have been purged
$(addsuffix -true, mklinks rmlinks $(YAM_LINKMOD_RULES) $(YAM_WORKMOD_RULES) $(YAM_ALLTGT_WORKMOD_RULES) $(YAM_ALLTGT_RULES) build all):


# ===== RULE DEFINITIONS ====

# We need to reinvoke Makeifile.yam here so that all the variables for exporting
# links, eg. INC_LINKS etc. which are unavailable duriing the first pass, are
# available in the second pass to do the real work of exporting the links
# Should look into a way to avoid this reinvocation
mklinks rmlinks:
ifeq ($(IS_VALID_TARGET),true)
	@$(MAKE) --no-print-directory -f Makefile.yam $@-real
endif

# define all the prerequisites for the standard Makefile.yam rules
# this -true part of this rule should be DELETED when all the -true
# variants of rules have been purged
mklinks rmlinks $(YAM_LINKMOD_RULES) $(YAM_WORKMOD_RULES): $(if $(IS_VALID_TARGET),% : checkSiteConfig %-std %-module %-true,invalid_msg)

# pull this out separately because this rule should be executed whether
# the module is supported or not
$(YAM_ALLTGT_RULES) $(YAM_ALLTGT_WORKMOD_RULES): % : checkSiteConfig %-std %-module %-true

#======================================================

CREATE_LINKS ?= $(YAM_ROOT)/etc/SiteDefs/mkHome/shared/create_links.bash

mklinks-real: mklinks-regular mklinks-mod mklinks-target

rmlinks-real: rmlinks-regular rmlinks-mod rmlinks-target

# to be deleted - here only for backwards compatibility
yam-reg-mklinks yam-reg-rmlinks:
	@echo "   !!! '$@' is a deprecated build target. !!! "
	@echo "   !!! Please delete it from your Makefile.yam. !!! "

# these exports are needed for the ifneq stuff in the link export template
# rules to work
export INC_LINKS
export LIB_LINKS
export DOC_LINKS
export ETC_LINKS
export BIN_LINKS

export INC_MODULE_LINKS
export LIB_MODULE_LINKS
export DOC_MODULE_LINKS
export ETC_MODULE_LINKS
export BIN_MODULE_LINKS

export INC_MODULE_LINKS_SUBPATH
export LIB_MODULE_LINKS_SUBPATH
export DOC_MODULE_LINKS_SUBPATH
export ETC_MODULE_LINKS_SUBPATH
export BIN_MODULE_LINKS_SUBPATH

export LIB_TARGET_LINKS
export BIN_TARGET_LINKS
export LIB_$(YAM_TARGET)_LINKS
export BIN_$(YAM_TARGET)_LINKS

LINKDIR_INC_LINKS := include
LINKDIR_LIB_LINKS := lib
LINKDIR_BIN_LINKS := bin
LINKDIR_ETC_LINKS := etc
LINKDIR_DOC_LINKS := doc

TOP_LINKDIR_TYPES := BIN DOC ETC INC LIB

# set default mode for exporting link module links to export links rather
# than copying the links into physical files
CPLINKS ?= 0

#--------------------------------------
# rules for creating and removing exported links
# 1 - YAM_ROOT's subdir to create link in
# 2 - list of module file subpaths whose links are to be exported
# 3 - the path from the target directory to the module location
exportmklinks = $(CREATE_LINKS) $(YAM_ROOT) $(1) $(3) $(CPLINKS) $(2)
exportrmlinks = $(addprefix $(YAM_ROOT)/$(1)/,$(notdir $(2)) )

# rules for exporting and removing single file to different link name
# (for the same name use the exportmklinks etc. rules above)
# 1 - YAM_ROOT's subpath to create link to (the destination link)
# 2 - subpath whose links are to be exported
# 3 - the path from the target directory to the module location
exportsinglelink = if (test -h $(YAM_ROOT)/$(1)) then :;  \
           else \
             echo "   linking $(2) into ./$(1) ..."; \
	    	    mkdir -p $(dir $(YAM_ROOT)/$(1)); \
                    ln -s $(3)/$(2) $(YAM_ROOT)/$(1); \
            fi;



mklinks-regular: $(foreach f, $(TOP_LINKDIR_TYPES), mklinks-regular-$(f)_LINKS)

# create a template rule to be used to create a rule for each type of
# variable defining links to be exported
# This rule does not do a shell invocation if no links need to be exported
define mklinks-regular-TEMPLATE
  mklinks-regular-$(1)_LINKS:
      ifneq ($($(1)_LINKS),)
	@$(call exportmklinks,$(LINKDIR_$(1)_LINKS), $($(1)_LINKS), \
	      $(RELLNK_DIR))
      endif
endef

# The following usage requires GNU make 3.81 or greater
# instantiate a rule for each regular link variable type (eg. BIN_LINKS,
# ETC_LINKS etc.)
$(foreach type, $(TOP_LINKDIR_TYPES), $(eval $(call mklinks-regular-TEMPLATE,$(type))))


#--------------------------------------
# rule to create all the module sub-directory links (eg. BIN_MODULE_LINKS)
mklinks-mod: $(foreach f, $(TOP_LINKDIR_TYPES), mklinks-mod-$(f)_MODULE_LINKS)

# create a template rule to be used to create a rule for each type of
# variable defining links to be exported
# This rule does not do a shell invocation if no links need to be exported
define mklinks-mod-TEMPLATE
  mklinks-mod-$(1)_MODULE_LINKS:
      ifneq ($($(1)_MODULE_LINKS),)
        ifeq ($($(1)_MODULE_LINKS_SUBPATH),)
	  @$(call exportmklinks,$(LINKDIR_$(1)_LINKS)/$(MODULE_NAME), \
              $($(1)_MODULE_LINKS), $(RELMODLNK_DIR) )
        else
	  @$(call exportmklinks, \
		$(LINKDIR_$(1)_LINKS)/$($(1)_MODULE_LINKS_SUBPATH), \
                $($(1)_MODULE_LINKS), $(LOCAL_DIR) )
        endif
      endif
endef

# instantiate a rule for each module sub-directory link variable type
# (eg. BIN_MODULE_LINKS, ETC_MODULE_LINKS etc.)
$(foreach type, $(TOP_LINKDIR_TYPES), $(eval $(call mklinks-mod-TEMPLATE,$(type))))

#--------------------------------------
# rule to create all the module sub-directory links (eg. BIN_MODULE_LINKS)
mklinks-target:: mklinks-target-BIN_TARGET_LINKS

# create a template rule to be used to create a rule for each type of
# variable defining links to be exported
# This rule does not do a shell invocation if no links need to be exported
define mklinks-target-TEMPLATE
  mklinks-target-$(1)_TARGET_LINKS:
      ifneq ($($(1)_TARGET_LINKS),)
	@$(call exportmklinks,$(LINKDIR_$(1)_LINKS)/$(YAM_TARGET), \
              $($(1)_TARGET_LINKS), $(RELTGTLNK_DIR) )
      endif
      ifneq ($($(1)_$(YAM_TARGET)_LINKS),)
	@$(call exportmklinks,$(LINKDIR_$(1)_LINKS)/$(YAM_TARGET), \
              $($(1)_$(YAM_TARGET)_LINKS), $(RELTGTLNK_DIR) )
      endif
endef

# instantiate a rule for each module sub-directory link variable type
# (eg. BIN_MODULE_LINKS, ETC_MODULE_LINKS etc.)
$(eval $(call mklinks-target-TEMPLATE,BIN))
$(eval $(call mklinks-target-TEMPLATE,LIB))


ifeq ($(BUILDING_SHARED_LIBS),true)
   mklinks-target:: mklinks-target-LIB_TARGET_LINKS
endif

#--------------------------------------
# rule to create all the target sub-directory static library
# links (eg. LIB_TARGET_LINKS)

# create a template rule to be used to create a rule for each type of
# variable defining links to be exported
# This rule does not do a shell invocation if no links need to be exported

mklinks-staticlibs-target:
	@$(call exportmklinks,$(LINKDIR_LIB_LINKS)/$(YAM_TARGET)-static, \
              $(LIB_STATIC_TARGET_LINKS), $(RELTGTLNK_DIR) )

ifeq ($(BUILD_STATIC_LIBS),true)
  mklinks-target:: mklinks-staticlibs-target
endif

# remove the top-level links
rmlinks-regular:
	@rm -f $(foreach f, $(TOP_LINKDIR_TYPES), \
            $(call exportrmlinks,$(LINKDIR_$(f)_LINKS),$($(f)_LINKS)) )

# remove the module sub-directory links
rmlinks-mod: $(foreach f, $(TOP_LINKDIR_TYPES), rmlinks-mod-$(f))

define rmlinks-mod-TEMPLATE
  rmlinks-mod-$(1):
      ifeq ($($(1)_MODULE_LINKS_SUBPATH),)
	@rm -rf $(YAM_ROOT)/$(LINKDIR_$(1)_LINKS)/$(MODULE_NAME)
      else
	@rm -f $(call exportrmlinks,$(LINKDIR_$(1)_LINKS)/$($(1)_MODULE_LINKS_SUBPATH), $($(1)_MODULE_LINKS))
      endif
endef

# The following usage requires GNU make 3.81 or greater
# instantiate a rule for each regular link variable type (eg. BIN_LINKS,
# ETC_LINKS etc.)
$(foreach type, $(TOP_LINKDIR_TYPES), $(eval $(call rmlinks-mod-TEMPLATE,$(type))))

# remove all the target specific links
rmlinks-target:
	@rm -f $(foreach t, $(MODULE_SUPPORTED_TARGETS), \
	  $(call exportrmlinks,lib/$(t), \
               $(notdir $(LIB_TARGET_LINKS) $(LIB_$(t)_LINKS))) \
          $(call exportrmlinks,lib/$(t)-static, \
               $(notdir $(LIB_STATIC_TARGET_LINKS))) \
          $(call exportrmlinks,bin/$(t), \
               $(notdir $(BIN_TARGET_LINKS))) \
          )

#=======================================================
#              All target build rules
#=======================================================

# The rule alltgt-xxx is used to conduct builds for all the site
# supported targest for rule "xxx" by sshing to the appropriate hosts
# The list of targets for which the build is conducted can be restricted
# using the ALLTGT variable
ifeq ($(ALLTGT),)
  FILT_ALLTGT := $(SITE_SUPPORTED_TARGETS)
else
  FILT_ALLTGT := $(filter $(SITE_SUPPORTED_TARGETS),$(ALLTGT))
endif

# filter out any targets that are not supposed to be built using the
# alltgt-xxx rules. An example is the cygwin target which may be supported
# but there may be no way to get remote access to the platform to build it
FILT_ALLTGT := $(foreach tgt, $(FILT_ALLTGT), $(if $(COMPILE_HOST-$(tgt)), $(tgt)) )

ifneq ($(SKIP_ALLTGT_TARGETS),)
  FILT_ALLTGT := $(filter-out $(SKIP_ALLTGT_TARGETS), $(FILT_ALLTGT))
endif

ifndef DATETAG
  export DATETAG := $(shell date '+%H%M%S')
endif

alltgt-%:
	@echo "A parallel make is being run for the '$*' rule for all targets."
	@echo "Progress is being logged in 'tmp-$*-$(DATETAG)-<tgt>' file in"
	@echo "$(LOCAL_DIR) for the following targets/hosts:\n"
	@$(call hostsstr,$(FILT_ALLTGT))
	@echo "\nThese temporary log files will be deleted on the completion of the make."
	@echo "\n\t\t\t========="
	@echo "\t\t\t WARNING"
	@echo "\t\t\t========="
	@echo "   The parallel makes will hang unless you have password-less"
	@echo "   remote access configured for the build machines. Please verify"
	@echo "   that such access is set up properly by running '$(MAKE) rshtest'."
	@echo ""
	@$(MAKE) --no-print-directory -j $(NUMPAR) -f Makefile.yam TGTRULE=$* \
                      DTAG=$(DATETAG) $(addsuffix -partgt,$(FILT_ALLTGT))
	@$(foreach t, $(FILT_ALLTGT), cat $(LOCAL_DIR)/tmp-$*-$(DATETAG)-$(t); rm -f tmp-$*-$(DATETAG)-$(t);)

%-partgt:
	@rm -f $(LOCAL_DIR)/tmp-$(TGTRULE)-$*-$(DTAG)
	@(echo "----------------------------------"; \
	 echo "Making $(TGTRULE) on host $(COMPILE_HOST-$*) for $* target ..."; \
	 $(RSHCMD) $(COMPILE_HOST-$*) \
			 '$(MAKE) --no-print-directory -C $(LOCAL_DIR) -f Makefile.yam YAM_SITE=$(YAM_SITE) YAM_TARGET=$* YAM_ROOT=$(YAM_ROOT) MYVARS=$(MYVARS) $(TGTRULE)') > $(LOCAL_DIR)/tmp-$(TGTRULE)-$(DTAG)-$* 2>&1
	@echo "==> Done with '$(TGTRULE)' on host '$(COMPILE_HOST-$*)' for '$*' target"

# empties out suffixes for automatic rules
.SUFFIXES:
