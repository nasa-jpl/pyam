########################################################################
#
# !!!!!! DO NOT EDIT THIS FILE !!!!!!
#
# This file is created by pyam.
#
########################################################################
#
# A top level Makefile for building the yam software this includes the
# YAM.config file to get definitions of the WORK_MODULES and LINK_MODULES
# variables.

SITEDEFSHOME ?= $(YAM_ROOT)/etc/SiteDefs
export SITEDEFSHOME

# Get the definitions of environment variables.
include $(YAM_ROOT)/etc/SiteDefs/mkHome/auto/site.env

# Add any local rules specific to the yam installation.
ifeq ($(YAM_ROOT)/etc/SiteDefs/mkHome/local-common.mk,$(wildcard $(YAM_ROOT)/etc/SiteDefs/mkHome/local-common.mk))
  include $(YAM_ROOT)/etc/SiteDefs/mkHome/local-common.mk
endif

# Get supported targets for the site.
ifdef YAM_SITE
  ifeq ($(YAM_ROOT)/etc/SiteDefs/mkHome/shared/supported.mk,$(wildcard $(YAM_ROOT)/etc/SiteDefs/mkHome/shared/supported.mk))
    include $(YAM_ROOT)/etc/SiteDefs/mkHome/auto/$(YAM_SITE)-site-supported.mk
    # include any user specific overrides on the target build hosts
    ifeq ($(HOME)/.site-hosts.mk,$(wildcard $(HOME)/.site-hosts.mk))
      include $(HOME)/.site-hosts.mk
    endif
    include $(YAM_ROOT)/etc/SiteDefs/mkHome/shared/supported.mk
  endif
endif


# Set a default value for the targets to build for.
YAM_TARGETS = $(YAM_TARGET)

# Macro to reverse a lsit, eg. $(call reverse, a b c d e).
reverseList = $(foreach i, $1, \
            $(eval $(if $(STK),,STK := $1)) \
            $(call indexelt, $(words $(STK)), $1 ) \
                $(eval STK := $(call allbutfirst, $(STK) )) )

#=======================================================
# Basic build rules
#=======================================================

all: mklinks build

build: $(YAM_BUILD_RULES)

ifdef QUIET
  PRINTDIR_ARG := --no-print-directory
else
  PRINTDIR_ARG :=
endif

#==================================================
# This rule builds target subdirectories for ALL_YAM_TARGETS under
# "lib" and "bin".
mk-tgt-dirs: $(foreach t, $(ALL_YAM_TARGETS), mkdir-libtgt-$(t) mkdir-bintgt-$(t) )

mkdir-libtgt-%:
	@mkdir -p lib/$*
mkdir-bintgt-%:
	@mkdir -p bin/$*

#==================================================
yam-mklinks yam-rmlinks::
	@echo "   !!! 'yam-mklinks/yam-rmlinks' are deprecated build targets. !!! "
	@echo "   !!! Please use the equivalent mklinks/rmlinks rules instead. !!! "

yam-mklinks:: mklinks
yam-rmlinks:: rmlinks


%-true::
	@echo "   !!! '$@' is a deprecated build target. !!!"
	@echo "   !!! Please use the equivalent '$*' build rule instead. !!!"



mklinks:: mkdir-libtgt-$(YAM_TARGET) mkdir-bintgt-$(YAM_TARGET) lms
rmlinks:: rmlms

mklinks rmlinks $(YAM_LINKMOD_RULES)::
	@$(MAKE) --no-print-directory -i RULE=$@ $(foreach t, $(YAM_TARGETS), allmods-rule-target-$(t) )

$(YAM_WORKMOD_RULES) $(YAM_ALLTGT_RULES) $(YAM_ALLTGT_WORKMOD_RULES)::
	@$(MAKE) --no-print-directory -i RULE=$@ $(foreach t, $(YAM_TARGETS), workmods-rule-target-$(t) )

# This is an intermediate rule (it required RULE variable to be set).
allmods-rule-target-%:
	# Parallelizing has trouble with rmlinks where SiteDefs link gets
	# deleted too early.
	@$(MAKE) rule-link-modules rule-work-modules YAM_TARGET=$*

# This is an intermediate rule (it required RULE variable to be set).
workmods-rule-target-%:
	#@$(MAKE) rule-work-modules YAM_TARGET=$*
	# keep this verbose for now for debugging parallel makes
	$(MAKE) $(YAM_MKPLL) rule-work-modules YAM_TARGET=$*

# These apply the RULE rule for YAM_TARGET target for all work modules.
rule-work-modules: CREATE_SITEDEFS_LINK $(foreach m,$(WORK_MODULES),rule-work-module-$(m) )

# Need to replace the '/' in link module string with '@' temporarily to avoid
# confusing the make which cannot handle '/'.
flinkmod = $(subst /,@,$(1))
blinkmod = $(subst @,/,$(1))

# These run the RULE rule for YAM_TARGET target for all link modules.
rule-link-modules: $(foreach m,$(LINK_MODULES),rule-link-module-$(call flinkmod,$(m)) )

# This runs the RULE rule for the YYAM_TARGET target for a work module.
rule-work-module-%:
ifndef QUIET
	@echo ""
	@echo "*********************************************************"
	@echo "Building \"$(RULE)\" for '$*/$(YAM_TARGET)' (`date '+%m/%d/%y %H:%M:%S'`) ... "
	@echo "*********************************************************"
endif
	@$(MAKE) $(PRINTDIR_ARG) -C src/$* -k -f Makefile.yam $(RULE)
ifndef QUIET
	@echo "=== Finished with '$(RULE)' rule for '$*' (`date '+%m/%d/%y %H:%M:%S'`) ... ==="
endif

rule-link-module-%:
ifndef QUIET
	@echo ""
	@echo "*********************************************************"
	@echo "Building \"$(RULE)\" for '$(call blinkmod,$*)/$(YAM_TARGET)' (`date '+%m/%d/%y %H:%M:%S'`) ... "
	@echo "*********************************************************"
endif
	# If the link-module entry is an existing file then a full path has
	# has been specified and we should directly use it. Else prefix
	# the entry with the module release directory.
	@if test -d "$(call blinkmod,$*)" ; then \
	     $(MAKE) $(PRINTDIR_ARG) -C $(call blinkmod,$*) -k -f Makefile.yam $(RULE) IS_WORK_MODULE=false; \
	else \
	     $(MAKE) $(PRINTDIR_ARG) -C $(YAM_VERSIONS)/$(call blinkmod,$*) -k -f Makefile.yam $(RULE) IS_WORK_MODULE=false; \
	fi;
ifndef QUIET
	@echo "=== Finished with '$(RULE)' rule for '$(call blinkmod,$*)' ==="
endif

# Rule to create lms/ directory with links to the link module sources.
mkdir-lms:
	@mkdir -p lms

.PHONY: lms

lmsnm = $(subst /,,$(dir $(1)))

# This is more robust - avoids recursive links from race conditions.
lmsmod = perl -e "symlink(qq@$(YAM_VERSIONS)/$(1)@, qq@lms/$(call lmsnm,$(1))@ )";

lms:  mkdir-lms
	@$(foreach m, $(LINK_MODULES), $(call lmsmod,$(m)) )

lm-rmlms:
	@echo "Removing lms links"
	@rm -f $(foreach m, $(LINK_MODULES), lms/$(subst /,,$(dir $(m))) )

wm-rmlms:
	@rm -f $(foreach m, $(WORK_MODULES), lms/$(m) )

rmlms: lm-rmlms wm-rmlms

#=======================================================
# Utility rules
#=======================================================

# Deletes the top level directories containing the exported links.
clean-links:
	@echo "Deleting bin doc etc include lib directories ..."
	@rm -rf bin doc etc include lib lms

# Strip all the libraries and binaries in the sandbox.
strip:
	@echo "Stripping all $(YAM_TARGET) binaries and libraries in bin/ and lib/ ..."
	chmod +w lib/$(YAM_TARGET)/* bin/$(YAM_TARGET)/*
	@$(STRIP) lib/$(YAM_TARGET)/* bin/$(YAM_TARGET)/*
	chmod -w lib/$(YAM_TARGET)/* bin/$(YAM_TARGET)/*

#=======================================================
# All target build rules
#=======================================================

# The rule alltgt-xxx is used to conduct builds for all the site
# supported targest for rule "xxx" by rsh'ng to the appropriate hosts
# The list of targets for which the build is conducted can be restricted
# using the ALLTGT variable
ifeq ($(ALLTGT),)
  FILT_ALLTGT := $(SITE_SUPPORTED_TARGETS)
else
  FILT_ALLTGT := $(filter $(SITE_SUPPORTED_TARGETS),$(ALLTGT))
endif

# Filter out any targets that are not supposed to be built using the
# alltgt-xxx rules. An example is the cygwin target which may be supported
# but there may be no way to get remote access to the platform to build it.
FILT_ALLTGT := $(foreach tgt, $(FILT_ALLTGT), $(if $(COMPILE_HOST-$(tgt)), $(tgt)) )

ifneq ($(SKIP_ALLTGT_TARGETS),)
  FILT_ALLTGT := $(filter-out $(SKIP_ALLTGT_TARGETS), $(FILT_ALLTGT))
endif

# Check whether the LINK_MODULES specification is coming from the YAM.config
# file. If yes, then we do not need to pass its value with every make
# invocation because each one will pick it up properly. We pass the value
# on only if it did not come from the file indicating that a restricted
# number of work/link modules are the target.
LINK_MOD_SRC = $(origin LINK_MODULES)
ifneq ($(LINK_MOD_SRC),file)
  MODSLIST = LINK_MODULES="$(LINK_MODULES)" WORK_MODULES1="$(WORK_MODULES1)"
endif

ifdef MODULES
  MODSLIST = LINK_MODULES="$(LINK_MODULES)" WORK_MODULES="$(WORK_MODULES)"
endif

# Create a "unique" tag for temporary files for parallel make builds.
ifndef DATETAG
 export DATETAG := $(shell date '+%H%M%S')
endif

alltgt-%:
	@echo "A parallel make is being run for the '$*' rule for all targets."
	@echo "Progress is being logged in a 'tmp-$*-$(DATETAG)-<tgt>' file in"
	@echo "$(CURDIR) for each of the following targets:\n"
	@$(call hostsstr,$(FILT_ALLTGT))
	@echo "\nThese temporary log files will be deleted on the completion of the make"
	@echo "\n\t\t\t========="
	@echo "\t\t\t WARNING"
	@echo "\t\t\t========="
	@echo "   The parallel makes will hang unless you have password-less"
	@echo "   remote access configured for the build machines. Please verify"
	@echo "   that such access is set up properly by running '$(MAKE) rshtest'."
	@echo ""
	@printf "Start time: "
	@date
	@$(MAKE) --no-print-directory -j $(NUMPAR) TGTRULE=$* \
                      DTAG=$(DATETAG) $(addsuffix -partgt,$(FILT_ALLTGT)) $(MODSLIST)
	@$(foreach t, $(FILT_ALLTGT), cat $(YAM_ROOT)/tmp-$*-$(DATETAG)-$(t); rm -f tmp-$*-$(DATETAG)-$(t);)
	@printf "End time: "
	@date

# Need to add the "-j 1" option to the local invocation of make because
# otherwise this make also goes into parallel mode swamping the machine.
%-partgt:
	@rm -f $(YAM_ROOT)/tmp-$(TGTRULE)-$*-$(DTAG)
	@(echo "----------------------------------"; \
            if [ $(COMPILE_HOST-$*) = $(HOST) ]; then \
	      echo "Making $(TGTRULE) on local host '$(COMPILE_HOST-$*)' for '$*' target ...";  \
		 $(MAKE) --no-print-directory -j 1 -C $(YAM_ROOT) -f Makefile YAM_TARGET=$* $(TGTRULE) ; \
            else \
	      echo "Making $(TGTRULE) on remote host '$(COMPILE_HOST-$*)' for '$*' target ...";  \
                $(RSHCMD) $(COMPILE_HOST-$*) \
			 '$(MAKE) --no-print-directory -C $(YAM_ROOT) -f Makefile YAM_TARGET=$* YAM_SITE=$(YAM_SITE) $(MODSLIST) $(TGTRULE)' ; \
            fi; ) > $(YAM_ROOT)/tmp-$(TGTRULE)-$(DTAG)-$* 2>&1
	@echo "==> Done with '$(TGTRULE)' on host '$(COMPILE_HOST-$*)' for '$*' target"

rshtest: $(foreach t,$(FILT_ALLTGT),rshtgt-$(t) )

rshtgt-%:
	@echo "----------------------------------"
	@echo "Checking '$(RSHCMD)' access to '$(COMPILE_HOST-$*)' for '$*' target ..."
	@$(RSHCMD) $(COMPILE_HOST-$*) echo "SUCCESS"
