########################################################################
#
#      !!!!!! DO NOT EDIT THIS FILE !!!!!!
#
#  This file is created by yamInstall. Run yamInstall to update
#  the contents of this file.
#
########################################################################
#
# a top level Makefile for building the YAM software
# this includes the YAM.config file to get definitions of the
# WORK_MODULES and LINK_MODULES variables

SITEDEFSHOME ?= $(YAM_ROOT)/etc/SiteDefs
export SITEDEFSHOME

# get the definitions of environment variables
include $(YAM_ROOT)/etc/SiteDefs/mkHome/auto/site.env

# add any local rules specific to the YaM installation
ifeq ($(YAM_ROOT)/etc/SiteDefs/mkHome/local-common.mk,$(wildcard $(YAM_ROOT)/etc/SiteDefs/mkHome/local-common.mk))
  include $(YAM_ROOT)/etc/SiteDefs/mkHome/local-common.mk
endif

#=======================================================
# get supported targets for the site
ifdef YAM_SITE
  ifeq ($(YAM_ROOT)/etc/SiteDefs/mkHome/shared/supported.mk,$(wildcard $(YAM_ROOT)/etc/SiteDefs/mkHome/shared/supported.mk))
    include $(YAM_ROOT)/etc/SiteDefs/mkHome/auto/$(YAM_SITE)-site-supported.mk
    # include any user specific overrides on the target build hosts
    ifeq ($(HOME)/.site-hosts.mk,$(wildcard $(HOME)/.site-hosts.mk))
      include $(HOME)/.site-hosts.mk
    endif
    include $(YAM_ROOT)/etc/SiteDefs/mkHome/shared/supported.mk
  endif
endif


# set a default value for the targets to build for
YAM_TARGETS = $(YAM_TARGET)

# macro to reverse a lsit, eg. $(call reverse, a b c d e)
reverseList = $(foreach i, $1, \
            $(eval $(if $(STK),,STK := $1)) \
            $(call indexelt, $(words $(STK)), $1 ) \
                $(eval STK := $(call allbutfirst, $(STK) )) )

#=======================================================
#	       Basic build rules
#=======================================================

all: mklinks build

#build: links depends docs libs libsso bins
build: $(YAM_BUILD_RULES)

ifdef QUIET
  PRINTDIR_ARG 		:= --no-print-directory
else
  PRINTDIR_ARG		:=
endif

#==================================================
# this rule builds target subdirectories for ALL_YAM_TARGETS under
# lib/ and bin/
mk-tgt-dirs: $(foreach t, $(ALL_YAM_TARGETS), mkdir-libtgt-$(t) mkdir-bintgt-$(t) )

mkdir-libtgt-%:
	@mkdir -p lib/$*
mkdir-bintgt-%:
	@mkdir -p bin/$*

#==================================================
yam-mklinks yam-rmlinks::
	@echo "   !!! 'yam-mklinks/yam-rmlinks' are deprecated build targets. !!! "
	@echo "   !!! Please use the equivalent mklinks/rmlinks rules instead. !!! "

yam-mklinks:: mklinks
yam-rmlinks:: rmlinks


%-true::
	@echo "   !!! '$@' is a deprecated build target. !!!"
	@echo "   !!! Please use the equivalent '$*' build rule instead. !!!"



mklinks:: mkdir-libtgt-$(YAM_TARGET) mkdir-bintgt-$(YAM_TARGET) lms
rmlinks:: rmlms

mkRelLinks:
	# echo "XXXXXXX"
	symlinks -c -r bin doc etc include lib



mklinks $(YAM_LINKMOD_RULES)::
	@$(MAKE) $(YAM_MKPLL) --no-print-directory -i RULE=$@ $(foreach t, $(YAM_TARGETS), allmods-rule-target-$(t) )

# avoid parallel builds for rmlinks because the SiteDefs link gets deleted too early
rmlinks ::
	@$(MAKE) --no-print-directory -i RULE=$@ $(foreach t, $(YAM_TARGETS), allmods-rule-target-$(t) )



mklinks:: mkRelLinks

$(YAM_WORKMOD_RULES) $(YAM_ALLTGT_RULES) $(YAM_ALLTGT_WORKMOD_RULES)::
	@$(MAKE) --no-print-directory -i RULE=$@ $(foreach t, $(YAM_TARGETS), workmods-rule-target-$(t) )

# this is an intermediate rule (it required RULE variable to be set)
allmods-rule-target-%:
	@$(MAKE) rule-link-modules rule-work-modules YAM_TARGET=$*
	# parallelizing has trouble with rmlinks where SiteDefs link gets deleted too early
	# $(MAKE) $(YAM_MKPLL) rule-link-modules rule-work-modules YAM_TARGET=$*

# this is an intermediate rule (it required RULE variable to be set)
workmods-rule-target-%:
	# keep this verbose for now for debugging parallel makes
	$(MAKE) $(YAM_MKPLL) rule-work-modules YAM_TARGET=$*

# these apply the RULE rule for YAM_TARGET target for all work modules
rule-work-modules: CREATE_SITEDEFS_LINK $(foreach m,$(WORK_MODULES),rule-work-module-$(m) )

# need to replace the '/' in link module string with '@' temporarily to avoid
# confusing the make which cannot handle '/'
flinkmod = $(subst /,@,$(1))
blinkmod = $(subst @,/,$(1))

# these run the RULE rule for YAM_TARGET target for all link modules
rule-link-modules: $(foreach m,$(LINK_MODULES),rule-link-module-$(call flinkmod,$(m)) )

# this runs the RULE rule for the YYAM_TARGET target for a work module
# add the LOCAL_DIR override for systems where it is determined by pwd and
# due to NFS mounting does not match the YAM_ROOT string
rule-work-module-%:
    ifndef QUIET
	@echo ""
	@echo "*********************************************************"
	@echo "Building \"$(RULE)\" for '$*/$(YAM_TARGET)' (`date '+%m/%d/%y %H:%M:%S'`) ... "
	@echo "*********************************************************"
    endif
	@$(MAKE) $(PRINTDIR_ARG) -C src/$* -k -f Makefile.yam $(RULE) LOCAL_DIR=$(YAM_ROOT)/src/$*
    ifndef QUIET
	@echo "   === Finished with '$(RULE)' rule for '$*' (`date '+%m/%d/%y %H:%M:%S'`) ... ==="
    endif
#       @echo "WORK module $*: rule=$(RULE) tgt=$(YAM_TARGET)"

rule-link-module-%:
    ifndef QUIET
	@echo ""
	@echo "*********************************************************"
	@echo "Building \"$(RULE)\" for '$(call blinkmod,$*)/$(YAM_TARGET)' (`date '+%m/%d/%y %H:%M:%S'`) ... "
	@echo "*********************************************************"
    endif
	# if the link module entry is an existing file then a full path has
	# has been specified and we should directly use it. Else prefix
	# the entry with the module release directory
	@if test -d "$(call blinkmod,$*)" ; then   \
	     $(MAKE) $(PRINTDIR_ARG) -C $(call blinkmod,$*) -k -f Makefile.yam $(RULE)  IS_WORK_MODULE=false; \
	else \
	     $(MAKE) $(PRINTDIR_ARG) -C $(YAM_VERSIONS)/$(call blinkmod,$*) -k -f Makefile.yam $(RULE)  IS_WORK_MODULE=false; \
	fi;
    ifndef QUIET
	@echo "   === Finished with '$(RULE)' rule for '$(call blinkmod,$*)' ==="
    endif

#=======================================================
# rule to create lms/ directory with links to the link module sources
mkdir-lms:
	@mkdir -p lms

.PHONY: lms

lmsnm  = $(subst /,,$(dir $(1)))
lmsmodOBSOLETE = if test -h $(YAM_ROOT)/lms/$(call lmsnm,$(1)) ; then  \
            echo " Link $(1) already exists"; \
         else \
            echo "   linking $(YAM_VERSIONS)/$(1) into ./lms/$(call lmsnm,$(1)) ..."; \
            ln -s $(YAM_VERSIONS)/$(1) lms/$(call lmsnm,$(1)); \
         fi;

# this is more robust - avoids recursive links from race conditions
lmsmod =  perl -e "symlink(qq@$(YAM_VERSIONS)/$(1)@, qq@lms/$(call lmsnm,$(1))@ )";

lms:  mkdir-lms
	@$(foreach m, $(LINK_MODULES), $(call lmsmod,$(m)) )

lm-rmlms:
	@echo "Removing lms links"
	@rm -f $(foreach m, $(LINK_MODULES), lms/$(subst /,,$(dir $(m))) )

wm-rmlms:
	@rm -f $(foreach m, $(WORK_MODULES), lms/$(m) )

rmlms: lm-rmlms wm-rmlms



#=======================================================
#	       Utility rules
#=======================================================

# deletes the top level directories containing the exported links
clean-links:
	@echo "Deleting bin doc etc include lib directories ..."
	@rm -rf bin doc etc include lib lms

# strip all the libraries and binaries in the sandbox
strip:
	@echo "Stripping all $(YAM_TARGET) binaries and libraries in bin/ and lib/ ..."
	chmod +w lib/$(YAM_TARGET)/* bin/$(YAM_TARGET)/*
	@$(STRIP) lib/$(YAM_TARGET)/* bin/$(YAM_TARGET)/*
	chmod -w lib/$(YAM_TARGET)/* bin/$(YAM_TARGET)/*

ifeq (common/.svn,$(wildcard common/.svn))
   USING_SVN=true
else
   USING_SVN=false
endif

cvs-update::
    ifeq ($(USING_SVN),true)
	# @echo "xx $(wildcard $(HOME)/common/.svn)"
	@echo "SVN updating common/ ..."
	@svn update --non-interactive -q common
    else
	@echo "CVS updating common/ ..."
	@cd common; cvs update
    endif

cvs-update cvscheck release-diffs config noplltest noplltestdata::
	@echo "   *********** Building '$@' rule ************"
	@$(MAKE) --no-print-directory $(foreach m, $(WORK_MODULES),$@-workmod-$(m) )
	@echo "   *********** Finished with '$@' rule ************"


#changelog-diffs:: $(foreach m, $(LINK_MODULES), config-linkmod-$(flinkmod $(m)) )


config:: $(foreach m, $(LINK_MODULES), config-linkmod-$(call flinkmod,$(m)) )

cvscheck::
    ifeq ($(USING_SVN),true)
	#@svn status -uq common | grep -v "Status against"
	@svn status -uq common
    else
	@echo "     running cvscheck on  \"common\" ..."
	@cd $(YAM_ROOT)/common; cvscheck | egrep -v "(directory|file) unknown"; cd ..
    endif

config-linkmod-%:
	@echo "$(call blinkmod,$*) (link module) ..."

noplltest-workmod-%:
	$(MAKE) -f Makefile.yam -C src/$* regtest

noplltestdata-workmod-%:
	$(MAKE) -f Makefile.yam -C src/$* regtestdata



cvs-update-workmod-%:
    ifeq ($(USING_SVN),true)
	@echo "SVN updating module \"$*\" ..."
	@svn update --non-interactive -q src/$*
    else
	@echo "ggg" $(wildcard src/$*/.svn) "hh"
	@echo "CVS updating module \"$*\" ..."
	@cd src/$*; cvs update -d -P
    endif


cvscheck-workmod-%:
    ifeq ($(USING_SVN),true)
#	svn status -uq src/$* | grep -v "(Status against)"
	@svn status -uq src/$*
    else
	@echo "     running cvscheck on module \"$*\" ..."
	@cd $(YAM_ROOT)/src/$*; cvscheck | egrep -v "(directory|file) unknown"; printf ""
    endif

config-workmod-%:
	@cd $(YAM_ROOT)/src/$*; \
	  cvs status Makefile.yam | grep "Sticky Tag" | sed -e s/"Sticky Tag:"/$*/g; \


release-diffs-workmod-%:
	@echo "==========================================================="
	@echo "Checking post release diffs for work module \"$*\" ..."
	@yam -nolog diff $*; \

#=======================================================
#	       All target build rules
#=======================================================

# The rule alltgt-xxx is used to conduct builds for all  the site
# supported targest for rule "xxx" by rsh'ng  to the appropriate hosts
# The list of targets for which the build  is  conducted can be restricted
# using the ALLTGT variable
ifeq ($(ALLTGT),)
  FILT_ALLTGT := $(SITE_SUPPORTED_TARGETS)
else
  FILT_ALLTGT := $(filter $(SITE_SUPPORTED_TARGETS),$(ALLTGT))
endif

# filter out any targets that are not supposed to be built using the
# alltgt-xxx rules. An example is the cygwin target which may be supported
# but there may be no way to get remote access to the platform to build it
FILT_ALLTGT := $(foreach tgt, $(FILT_ALLTGT), $(if $(COMPILE_HOST-$(tgt)), $(tgt)) )

ifneq ($(SKIP_ALLTGT_TARGETS),)
  FILT_ALLTGT := $(filter-out $(SKIP_ALLTGT_TARGETS), $(FILT_ALLTGT))
endif

# check whether the LINK_MODULES specification is coming from the YAM.config
# file. If yes, then we do not need to pass its value with every make
# invocation because each one will pick it up properly. We pass the value
# on only if it did not come from the file indicating that a restricted
# number of work/link modules are the target
LINK_MOD_SRC = $(origin LINK_MODULES)
ifneq ($(LINK_MOD_SRC),file)
  MODSLIST = LINK_MODULES="$(LINK_MODULES)" WORK_MODULES1="$(WORK_MODULES1)"
endif

ifdef MODULES
  MODSLIST = LINK_MODULES="$(LINK_MODULES)" WORK_MODULES="$(WORK_MODULES)"
endif

# create a "unique" tag for temporary files for parallel make builds
ifndef DATETAG
 export DATETAG := $(shell date '+%H%M%S')
endif

alltgt-%:
	@echo "A parallel make is being run for the '$*' rule for all targets."
	@echo "Progress is being logged in a 'tmp-$*-$(DATETAG)-<tgt>' file in"
	@echo "$(CURDIR) for each of the following targets:\n"
	@$(call hostsstr,$(FILT_ALLTGT))
	@echo "\nThese temporary log files will be deleted on the completion of the make"
	@echo "\n\t\t\t========="
	@echo "\t\t\t WARNING"
	@echo "\t\t\t========="
	@echo "   The parallel makes will hang unless you have password-less"
	@echo "   remote access configured for the build machines. Please verify"
	@echo "   that such access is set up properly by running '$(MAKE) rshtest'."
	@echo ""
	@printf "Start time: "
	@date
	@$(MAKE) --no-print-directory  -j $(NUMPAR)  TGTRULE=$* \
                      DTAG=$(DATETAG) $(addsuffix -partgt,$(FILT_ALLTGT)) $(MODSLIST)
	@$(foreach t, $(FILT_ALLTGT), cat $(YAM_ROOT)/tmp-$*-$(DATETAG)-$(t); rm -f tmp-$*-$(DATETAG)-$(t);)
	@printf "End time: "
	@date

# Need to add the "-j 1" option to the local invocation of make because
# otherwise this make also goes into parallel mode swamping the machine
%-partgt:
	@rm -f $(YAM_ROOT)/tmp-$(TGTRULE)-$*-$(DTAG)
	@(echo "----------------------------------"; \
            if [ $(COMPILE_HOST-$*) =  $(HOST) ]; then \
	      echo "Making $(TGTRULE) on local host '$(COMPILE_HOST-$*)' for '$*' target ...";  \
		 $(MAKE) --no-print-directory -j 1 -C $(YAM_ROOT) -f Makefile YAM_TARGET=$* $(TGTRULE) ; \
            else \
	      echo "Making $(TGTRULE) on remote host '$(COMPILE_HOST-$*)' for '$*' target ...";  \
                $(RSHCMD) $(COMPILE_HOST-$*) \
			 '$(MAKE) --no-print-directory -C $(YAM_ROOT) -f Makefile YAM_TARGET=$* YAM_SITE=$(YAM_SITE) $(MODSLIST) $(TGTRULE)' ; \
            fi; ) > $(YAM_ROOT)/tmp-$(TGTRULE)-$(DTAG)-$* 2>&1
	@echo "==> Done with '$(TGTRULE)' on host '$(COMPILE_HOST-$*)' for '$*' target"

rshtest: $(foreach t,$(FILT_ALLTGT),rshtgt-$(t) )

rshtgt-%:
	@echo "----------------------------------"
	@echo "Checking '$(RSHCMD)' access to '$(COMPILE_HOST-$*)' for '$*' target ..."
	@$(RSHCMD) $(COMPILE_HOST-$*) echo "SUCCESS"

#=======================================================
